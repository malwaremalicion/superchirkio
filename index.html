<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Super Chirk — Mini Platformer</title>
<style>
  html,body{height:100%;margin:0;background:#000;display:flex;align-items:center;justify-content:center;font-family:system-ui,Segoe UI,Roboto}
  canvas{background:#000;image-rendering:pixelated}
  #ui{position:fixed;left:12px;top:12px;color:#fff}
  button{padding:8px 12px;margin:6px}
</style>
</head>
<body>
<canvas id="game" width="960" height="540"></canvas>
<div id="ui"></div>
<script>
// === Super Chirk — fixed script ===

// Canvas + basic state
let canvas = null, ctx = null;
let gameState = "menu"; // menu, levelselect, cutscene, playing, win
let currentLevel = 1;
let unlockedLevels = JSON.parse(localStorage.getItem("unlockedLevels") || "[1]");
let game = { time: 0 };

// Music and pause
let bgm = null;
let bossMusic = null;
let cutsceneMusic = null;
let paused = false;

// Cutscene data
let inCutscene = false;
let cutsceneTimer = 0;
let cutsceneDialogue = [
    "wow",
    "you really made it this far",
    "It seems that your DEKIRKINATION took you pretty far.",
    "but no matter.",
    "your journey ends NOW"
]; // 22-second cutscene with timed dialogue

// Save unlocked levels
function unlockLevel(lv) {
    if (!unlockedLevels.includes(lv)) {
        unlockedLevels.push(lv);
        localStorage.setItem("unlockedLevels", JSON.stringify(unlockedLevels));
    }
}

// Draw level select
function drawLevelSelect() {
    ctx.fillStyle = "black";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle = "white";
    ctx.font = "24px sans-serif";
    ctx.fillText("LEVEL SELECT", 50, 50);

    unlockedLevels.forEach((lv, i)=>{
        ctx.fillText("Level " + lv, 60, 120 + i * 40);
    });

    ctx.font = "14px sans-serif";
    ctx.fillText("Press 1/2/3 to start an unlocked level. Press Z to return to menu.", 50, canvas.height - 40);
}

// === NEW OBJECTS FOR GAMEPLAY ===
let player = {x:50,y:240,w:32,h:48,vx:0,vy:0,onGround:false,facing:1,health:3,lives:3,invulnerable:0};
let enemies = [];
let fireballs = [];
let flags = [];
let gravity = 0.8;
let camera = {x:0,y:0};

// Input state
const input = {left:false,right:false,jump:false,run:false};
window.addEventListener('keydown', e=>{
    if(e.key==='ArrowLeft') input.left=true;
    if(e.key==='ArrowRight') input.right=true;
    if(e.key.toLowerCase()==='z') input.jump=true;
    if(e.key.toLowerCase()==='x') input.run=true;
});
window.addEventListener('keyup', e=>{
    if(e.key==='ArrowLeft') input.left=false;
    if(e.key==='ArrowRight') input.right=false;
    if(e.key.toLowerCase()==='z') input.jump=false;
    if(e.key.toLowerCase()==='x') input.run=false;
});

// Level definitions with platforms
const LEVEL_DATA = [
    {
        platforms: [ {x:0,y:360,w:2000,h:40}, {x:300,y:300,w:120,h:16}, {x:600,y:250,w:120,h:16} ],
        enemies: [ {x:420,y:320,patrol:[380,520]} ],
        flags: [{x:950,y:300,w:32,h:64}]
    },
    {
        platforms: [ {x:0,y:360,w:2000,h:40}, {x:180,y:300,w:140,h:16}, {x:480,y:260,w:140,h:16}, {x:780,y:220,w:140,h:16} ],
        enemies: [ {x:300,y:320,patrol:[260,420]}, {x:650,y:240,patrol:[620,740]} ],
        flags: [{x:950,y:200,w:32,h:64}]
    },
    {
        platforms: [ {x:0,y:360,w:2000,h:40}, {x:220,y:300,w:120,h:16}, {x:480,y:260,w:120,h:16}, {x:740,y:220,w:120,h:16} ],
        enemies: [ {boss:true,x:900,y:200,hp:3} ],
        flags: []
    }
];

// reset level: spawn enemies/flags
function resetLevel(levelNum){
    const L = LEVEL_DATA[levelNum-1];
    enemies = [];
    fireballs = [];
    flags = [];
    player.x = 60; player.y = 200; player.vx = 0; player.vy = 0; player.onGround = false; player.invulnerable = 0;

    // spawn enemies
    if(L.enemies) for(const e of L.enemies){
        if(e.boss) enemies.push({boss:true,x:e.x,y:e.y,w:64,h:64,hp:e.hp,cooldown:120});
        else enemies.push({boss:false,x:e.x,y:e.y,w:32,h:32,patrolMin:e.patrol[0],patrolMax:e.patrol[1],dir:1,speed:1.2});
    }
    // spawn flags
    if(L.flags) for(const f of L.flags) flags.push({x:f.x,y:f.y,w:f.w,h:f.h});
}

// drawing helpers and images
let imgPlayer = new Image(); imgPlayer.src = "chirk.png";
let imgEnemy  = new Image(); imgEnemy.src  = "cheese.png";
let imgBoss   = new Image(); imgBoss.src   = "supercheese.png";
let imgBall   = new Image(); imgBall.src   = "BALL.png";
let imgFlag   = new Image(); imgFlag.src   = "flag.png";
let imgBG     = new Image(); imgBG.src     = "bg.png";
let imgGround = new Image(); imgGround.src = "g.png";

function worldToScreen(x){ return Math.round(x - camera.x); }

// runLevel: physics, AI, drawing
function runLevel(levelNum){
    const L = LEVEL_DATA[levelNum-1];

    // draw bg tiled (if available)
    if(imgBG.complete && imgBG.width > 0){
        // tile horizontally
        const tileW = imgBG.width;
        const startX = -((camera.x % tileW + tileW) % tileW) - tileW;
        for(let bx = startX; bx < canvas.width; bx += tileW) ctx.drawImage(imgBG, bx, 0);
    } else {
        ctx.fillStyle = '#80c0ff'; ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    // player movement physics
    const accel = input.run ? 0.6 : 0.35;
    if(input.left) player.vx -= accel;
    if(input.right) player.vx += accel;
    // clamp speed
    const maxSpd = input.run ? 6 : 3.5;
    if(player.vx > maxSpd) player.vx = maxSpd;
    if(player.vx < -maxSpd) player.vx = -maxSpd;
    // friction
    player.vx *= 0.88;
    // jumping (edge detection)
    if(input.jump && player.onGround){ player.vy = -12; player.onGround = false; }

    // gravity
    player.vy += gravity; if(player.vy > 18) player.vy = 18;

    // tentative move
    player.x += player.vx; player.y += player.vy;

    // simple platform collisions and draw platforms
    player.onGround = false;
    for(const p of L.platforms){
        // draw ground tile repeated
        if(imgGround.complete && imgGround.width > 0){
            for(let gx = p.x; gx < p.x + p.w; gx += imgGround.width){
                ctx.drawImage(imgGround, worldToScreen(gx), p.y, imgGround.width, p.h);
            }
        } else {
            ctx.fillStyle = '#6b4'; ctx.fillRect(worldToScreen(p.x), p.y, p.w, p.h);
        }

        // AABB collision
        if(player.x < p.x + p.w && player.x + player.w > p.x && player.y < p.y + p.h && player.y + player.h > p.y){
            // from above?
            if(player.vy >= 0 && (player.y + player.h - player.vy) <= p.y + 6){
                player.y = p.y - player.h; player.vy = 0; player.onGround = true;
            } else {
                // horizontal push
                if(player.x < p.x) player.x = p.x - player.w; else player.x = p.x + p.w;
                player.vx = 0;
            }
        }
    }

    // camera follow (horizontal only)
    camera.x = player.x - canvas.width/2 + player.w/2;
    if(camera.x < 0) camera.x = 0;

    // draw player
    if(imgPlayer.complete) ctx.drawImage(imgPlayer, worldToScreen(player.x), player.y, player.w, player.h);
    else { ctx.fillStyle='cyan'; ctx.fillRect(worldToScreen(player.x),player.y,player.w,player.h); }

    // enemies update & draw
    for(const e of enemies){
        if(e.boss){
            e.x += Math.sin(game.time*0.8)*0.25;
            if(e.cooldown <= 0){
                // shoot towards player
                const dir = (player.x - e.x) > 0 ? 1 : -1;
                fireballs.push({x: e.x + (dir>0 ? e.w+4 : -20), y: e.y+24, vx: dir * 5, life:200});
                e.cooldown = 90;
            }
            e.cooldown--;
            if(imgBoss.complete) ctx.drawImage(imgBoss, worldToScreen(e.x), e.y, e.w, e.h);
            else { ctx.fillStyle='purple'; ctx.fillRect(worldToScreen(e.x), e.y, e.w, e.h); }
        } else {
            e.x += e.speed * e.dir;
            if(e.x < e.patrolMin) e.dir = 1;
            if(e.x > e.patrolMax) e.dir = -1;
            if(imgEnemy.complete) ctx.drawImage(imgEnemy, worldToScreen(e.x), e.y, e.w, e.h);
            else { ctx.fillStyle='red'; ctx.fillRect(worldToScreen(e.x), e.y, e.w, e.h); }
        }
    }

    // fireballs update & draw
    for(let i = fireballs.length-1; i>=0; i--){
        const b = fireballs[i];
        b.x += b.vx;
        b.life--;
        if(imgBall.complete) ctx.drawImage(imgBall, worldToScreen(b.x), b.y, 16, 16);
        else { ctx.fillStyle='orange'; ctx.fillRect(worldToScreen(b.x), b.y, 16, 16); }

        // collision with player
        if(player.invulnerable <= 0 && player.x < b.x+16 && player.x+player.w > b.x && player.y < b.y+16 && player.y+player.h > b.y){
            player.health -= 1;
            player.invulnerable = 90;
            player.x = Math.max(10, player.x - 60);
            try{ new Audio('ow.mp3').play(); }catch(e){}
            fireballs.splice(i,1);
            if(player.health <= 0){
                player.lives--;
                if(player.lives <= 0){
                    gameState = 'levelselect';
                    player.lives = 3; player.health = 3;
                } else {
                    resetLevel(levelNum);
                }
            }
            continue;
        }

        if(b.life <= 0) fireballs.splice(i,1);
    }

    // enemy collisions (stomp to kill)
    for(let i = enemies.length-1; i>=0; i--){
        const e = enemies[i];
        if(!e.boss){
            // stomp
            if(player.vy > 0 && player.y + player.h < e.y + 12 && player.x + player.w > e.x && player.x < e.x + e.w){
                try{ new Audio('owe.mp3').play(); }catch(e){}
                enemies.splice(i,1);
                player.vy = -8;
                continue;
            }
            // side collision
            if(player.invulnerable <= 0 && player.x < e.x + e.w && player.x + player.w > e.x && player.y < e.y + e.h && player.y + player.h > e.y){
                player.health -= 1;
                player.invulnerable = 90;
                player.x = Math.max(10, player.x - 40);
                try{ new Audio('ow.mp3').play(); }catch(e){}
                if(player.health <= 0){
                    player.lives--;
                    if(player.lives <= 0){
                        gameState='levelselect'; player.lives=3; player.health=3;
                    } else resetLevel(levelNum);
                }
            }
        } else {
            // boss stomp
            if(player.vy > 0 && player.y + player.h < e.y + 16 && player.x + player.w > e.x && player.x < e.x + e.w){
                e.hp--;
                try{ new Audio('owe.mp3').play(); }catch(e){}
                player.vy = -10;
                if(e.hp <= 0){
                    document.cookie='super_chirk_never_play=1; expires=Fri, 31 Dec 9999 23:59:59 GMT';
                    gameState='win';
                }
            }
        }
    }

    // draw flags and check goal
    for(const f of flags){
        if(imgFlag.complete) ctx.drawImage(imgFlag, worldToScreen(f.x), f.y, f.w, f.h);
        else ctx.fillStyle='yellow', ctx.fillRect(worldToScreen(f.x), f.y, f.w, f.h);

        if(player.x + player.w > f.x && player.x < f.x + f.w && player.y + player.h > f.y){
            unlockLevel(levelNum+1);
            resetLevel(levelNum+1);
            gameState='levelselect';
        }
    }

    // reduce invulnerability timer
    if(player.invulnerable > 0) player.invulnerable--;

    // HUD
    ctx.fillStyle='white'; ctx.font='16px sans-serif'; ctx.fillText('Level ' + levelNum, 10, 20);
    ctx.fillText('Health: ' + player.health + '  Lives: ' + player.lives, 10, 40);
}

// === Music init ===
function initMusic(){
    bgm = new Audio("bgm.mp3"); bgm.loop = true; bgm.volume = 0.5;
    bossMusic = new Audio("boss.mp3"); bossMusic.loop = true; bossMusic.volume = 0.7;
    cutsceneMusic = new Audio("cut.mp3"); cutsceneMusic.loop = false; cutsceneMusic.volume = 0.8;
    // attempt to play bgm (may be blocked until user gesture)
    bgm.play().catch(()=>{});
}

// game loop
let lastTime = performance.now();
function gameLoop(now){
    const dt = Math.min(0.05, (now - lastTime) / 1000);
    lastTime = now;
    game.time += dt;

    // clear
    ctx.clearRect(0,0,canvas.width,canvas.height);

    if (gameState === "menu") {
        ctx.fillStyle = "black";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = "white";
        ctx.fillText("SUPER CHIRK", 50, 50);
        ctx.fillText("Press Z to Start (level select)", 50, 100);
    }
    else if (gameState === "levelselect") {
        drawLevelSelect();
    }
    else if (gameState === "cutscene") {
        // 22-second cutscene with timed dialogue
        ctx.fillStyle = "black";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = "white";
        ctx.font = "24px sans-serif";

        // Play cutscene music at start
        if(cutsceneTimer === 0){
            try{ cutsceneMusic.currentTime = 0; cutsceneMusic.play().catch(()=>{}); }catch(e){}
        }

        // Timed dialogue: split 22 seconds into equal parts
        let lineIndex = Math.floor((cutsceneTimer / 22) * cutsceneDialogue.length);
        if (lineIndex >= cutsceneDialogue.length) lineIndex = cutsceneDialogue.length - 1;
        ctx.fillText(cutsceneDialogue[lineIndex], 120, 150);

        cutsceneTimer += dt;
        if (cutsceneTimer >= 22) {
            try{ cutsceneMusic.pause(); }catch(e){}
            inCutscene = false;
            currentLevel = 3;
            try{ bossMusic.currentTime = 0; bossMusic.play().catch(()=>{}); }catch(e){}
            resetLevel(3);
            gameState = "playing";
        }
    }
    else if (gameState === "playing") {
        if(!paused) runLevel(currentLevel);
        else {
            // paused overlay
            ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(0,0,canvas.width,canvas.height);
            ctx.fillStyle='white'; ctx.font='32px sans-serif'; ctx.fillText('PAUSED', 120, 120);
            ctx.font='18px sans-serif'; ctx.fillText('Press P to Resume', 110, 170);
            ctx.fillText('Press M for Menu', 110, 200);
        }
    }
    else if (gameState === "win") {
        ctx.fillStyle = "black";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = "white";
        ctx.fillText("YOU WIN!", 50, 50);
        ctx.fillText("Game permanently locked.", 50, 100);
    }

    requestAnimationFrame(gameLoop);
}

// input & UI keys (menu, levelselect, pause, start)
function onGlobalKey(e){
    // Pause toggle
    if (e.key.toLowerCase() === "p" && gameState === "playing") {
        paused = !paused;
        if (paused) { try{ bgm.pause(); bossMusic.pause(); }catch(err){} }
        else { try{ if(currentLevel === 3) bossMusic.play(); else bgm.play(); }catch(err){} }
    }

    // From pause to menu
    if (paused && e.key.toLowerCase() === "m") {
        paused = false;
        try{ bgm.play().catch(()=>{}); }catch(e){}
        gameState = "menu";
    }

    // Menu -> levelselect
    if (gameState === "menu" && e.key.toLowerCase() === "z") {
        gameState = "levelselect";
        return;
    }

    // Level selection
    if (gameState === "levelselect") {
        if (e.key === "1" && unlockedLevels.includes(1)) {
            currentLevel = 1;
            resetLevel(1);
            try{ bgm.currentTime = 0; bgm.play().catch(()=>{}); }catch(e){}
            gameState = "playing";
            return;
        }
        if (e.key === "2" && unlockedLevels.includes(2)) {
            currentLevel = 2;
            resetLevel(2);
            try{ bgm.currentTime = 0; bgm.play().catch(()=>{}); }catch(e){}
            gameState = "playing";
            return;
        }
        if (e.key === "3" && unlockedLevels.includes(3)) {
            // start cutscene then level 3
            inCutscene = true;
            cutsceneTimer = 0;
            try{ bgm.pause(); bossMusic.pause(); }catch(e){}
            gameState = "cutscene";
            return;
        }
    }
}

window.addEventListener('keydown', onGlobalKey);

// initialize
window.onload = () => {
    canvas = document.getElementById("game");
    ctx = canvas.getContext("2d");
    ctx.imageSmoothingEnabled = false;
    initMusic();
    requestAnimationFrame(gameLoop);
};

</script>
</body>
</html>
