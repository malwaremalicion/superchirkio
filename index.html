<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Super Chirk â€” Mini Platformer (Rebuilt)</title>
<style>
  html,body{height:100%;margin:0;background:#000;display:flex;align-items:center;justify-content:center;font-family:system-ui,Segoe UI,Roboto}
  canvas{background:#000;image-rendering:pixelated}
  #ui{position:fixed;left:12px;top:12px;color:#fff}
  button{padding:8px 12px;margin:6px}
</style>
</head>
<body>
<canvas id="game" width="960" height="540"></canvas>
<div id="ui"></div>

<script>
/*
 Full rebuilt single-file game:
 - Player speed doubled
 - Big level planes
 - Flags restored (level goal)
 - Boss: orbit attack (5s), fling + slow, orbit every 15s
 - While orbit NOT active: faster direct fire
 - Laser attack when boss hp < 20 every 20s
 - Boss HP = 30
 - Preserves prior behavior
*/

// ---------- Globals ----------
let canvas, ctx;
let gameState = "menu"; // menu, levelselect, cutscene, playing, win
let currentLevel = 1;
let unlockedLevels = JSON.parse(localStorage.getItem("unlockedLevels") || "[1]");
let game = { time: 0 };
let paused = false;
let FRAME = 0; // global frame counter

// ---------- Player / World ----------
let player = { x: 50, y: 240, w: 32, h: 48, vx: 0, vy: 0, onGround: false, facing: 1, health: 3, lives: 3, invulnerable: 0 };
let enemies = [];
let fireballs = []; // direct projectiles
let orbiters = [];  // orbit rings (visual + collision)
let lasers = [];    // active laser beams
let flags = [];
let camera = { x: 0, y: 0 };

// Gameplay constants (player speeds doubled from previous)
const GRAVITY = 0.8, MAX_FALL = 18;
const FRICTION = 0.88;
const WALK_ACCEL = 0.35 * 2, RUN_ACCEL = 0.6 * 2, MAX_WALK = 3.5 * 2, MAX_RUN = 6 * 2;
const JUMP_VY = -16, JUMP_HOR_BOOST = 2.5 * 2; // horizontal boost doubled

// Input
const input = { left: false, right: false, jump: false, run: false };
window.addEventListener('keydown', e => {
  if (e.key === 'ArrowLeft') input.left = true;
  if (e.key === 'ArrowRight') input.right = true;
  if (e.key.toLowerCase() === 'z') input.jump = true;
  if (e.key.toLowerCase() === 'x') input.run = true;
});
window.addEventListener('keyup', e => {
  if (e.key === 'ArrowLeft') input.left = false;
  if (e.key === 'ArrowRight') input.right = false;
  if (e.key.toLowerCase() === 'z') input.jump = false;
  if (e.key.toLowerCase() === 'x') input.run = false;
});

// ---------- Level data (very wide planes) ----------
const LEVEL_DATA = [
  {
    platforms: [{ x: 0, y: 360, w: 8000, h: 40 }, { x: 800, y: 300, w: 400, h: 16 }, { x: 1600, y: 250, w: 400, h: 16 }],
    enemies: [{ x: 420, patrol: [380, 520] }],
    flags: [{ x: 4000, w: 32, h: 80 }]
  },
  {
    platforms: [{ x: 0, y: 360, w: 8000, h: 40 }, { x: 600, y: 300, w: 400, h: 16 }, { x: 1400, y: 260, w: 400, h: 16 }, { x: 2200, y: 220, w: 400, h: 16 }],
    enemies: [{ x: 800, patrol: [760, 940] }, { x: 1800, patrol: [1720, 1840] }],
    flags: [{ x: 4200, w: 32, h: 80 }]
  },
  {
    platforms: [{ x: 0, y: 360, w: 8000, h: 40 }, { x: 900, y: 300, w: 400, h: 16 }, { x: 1900, y: 260, w: 400, h: 16 }, { x: 2800, y: 220, w: 400, h: 16 }],
    enemies: [{ boss: true, x: 1200, hp: 30, dir: 1 }],
    flags: [{ x: 4600, w: 32, h: 128 }]
  }
];

// ---------- Images (preload, but robust if missing) ----------
let imgPlayer = new Image(), imgEnemy = new Image(), imgBoss = new Image(), imgBall = new Image(), imgFlag = new Image(), imgBG = new Image(), imgGround = new Image(), imgBlaster = new Image(), imgLaser = new Image();
imgPlayer.src = "chirk.png";
imgEnemy.src = "cheese.png";
imgBoss.src = "supercheese.png";
imgBall.src = "BALL.png";
imgFlag.src = "flag.png";
imgBG.src = "bg.png";
imgGround.src = "g.png";
imgBlaster.src = "blaster.png";
imgLaser.src = "laser.png";

const ALL_IMAGES = [imgPlayer, imgEnemy, imgBoss, imgBall, imgFlag, imgBG, imgGround, imgBlaster, imgLaser];
let imagesLoaded = 0;
ALL_IMAGES.forEach(img => {
  img.onload = () => { imagesLoaded++; if (imagesLoaded === ALL_IMAGES.length) startGame(); };
  img.onerror = () => { imagesLoaded++; if (imagesLoaded === ALL_IMAGES.length) startGame(); };
});

// ---------- Helpers ----------
function worldToScreen(x) { return Math.round(x - camera.x); }
function unlockLevel(lv) { if (lv <= LEVEL_DATA.length && !unlockedLevels.includes(lv)) { unlockedLevels.push(lv); localStorage.setItem("unlockedLevels", JSON.stringify(unlockedLevels)); }}

// ---------- Reset Level ----------
function resetLevel(levelNum) {
  const L = LEVEL_DATA[levelNum - 1];
  enemies = []; fireballs = []; orbiters = []; lasers = []; flags = [];
  player.x = 60; player.y = 200; player.vx = 0; player.vy = 0; player.onGround = false; player.invulnerable = 0;

  if (L.enemies) L.enemies.forEach(e => {
    if (e.boss) {
      const ground = L.platforms[0];
      const bx = Math.max(ground.x + 16, Math.min(e.x, ground.x + ground.w - 80));
      enemies.push({
        boss: true,
        x: bx,
        y: ground.y - 64,
        w: 64, h: 64,
        hp: e.hp || 30,
        vx: 0, vy: 0,
        cooldown: 0,
        dir: e.dir || 1,
        hitCooldown: 0,
        // firing & orbit config
        directFireCooldownBase: 8,   // fast base while NOT orbiting
        orbitSlowFireCooldown: 240,  // during orbit (slow firing)
        slowUntilFrame: 0,           // fire-slow window (set while orbit active)
        orbitCooldown: 900,          // frames until next orbit (~15s)
        orbitActiveUntil: 0,         // frame when orbit ends
        moveMultiplier: 0.75,        // boss slower than normal
        slowMoveUntil: 0,            // movement slow window after fling
        nextLaserFrame: FRAME + 999999 // will be set when hp<20
      });
    } else {
      const plat = L.platforms.find(p => e.x >= p.x && e.x <= p.x + p.w) || L.platforms[0];
      const ex = Math.max(plat.x + 4, Math.min(e.x, plat.x + plat.w - 32));
      const patrolMin = Math.max(e.patrol[0], plat.x);
      const patrolMax = Math.min(e.patrol[1], plat.x + plat.w - 32);
      enemies.push({ boss: false, x: ex, y: plat.y - 32, w: 32, h: 32, patrolMin, patrolMax, dir: 1, speed: 1.2 });
    }
  });

  if (L.flags) L.flags.forEach(f => {
    const plat = L.platforms.find(p => f.x >= p.x && f.x <= p.x + p.w) || L.platforms[0];
    flags.push({ x: f.x, y: plat.y - f.h, w: f.w, h: f.h, visible: false });
  });
}

// ---------- Orbit helpers ----------
function spawnOrbitAroundPlayer(bossRef, count = 20, radius = 110, lifetimeFrames = 300, speed = 0.08) {
  // Mark boss as orbit-active (fire slowed for orbit duration)
  bossRef.slowUntilFrame = Math.max(bossRef.slowUntilFrame || 0, FRAME + lifetimeFrames);
  bossRef.orbitActiveUntil = FRAME + lifetimeFrames;
  orbiters.push({ boss: bossRef, t: 0, count, radius, life: lifetimeFrames, speed, createdAtFrame: FRAME });
}

// ---------- Laser helper ----------
function spawnLaserFromBoss(bossRef, lifeFrames = 90) {
  const sx = bossRef.x + bossRef.w / 2;
  const sy = bossRef.y + bossRef.h / 2;
  lasers.push({ owner: bossRef, sx, sy, life: lifeFrames, maxLife: lifeFrames, createdAt: FRAME, width: 16 });
}

// point-to-segment distance
function pointToSegmentDist(px, py, x1, y1, x2, y2) {
  const vx = x2 - x1, vy = y2 - y1, wx = px - x1, wy = py - y1;
  const c = (wx * vx + wy * vy) / (vx * vx + vy * vy || 1);
  const t = Math.max(0, Math.min(1, c));
  const rx = x1 + vx * t, ry = y1 + vy * t;
  const dx = px - rx, dy = py - ry;
  return Math.sqrt(dx * dx + dy * dy);
}

// ---------- Run Level ----------
function runLevel(levelNum) {
  const L = LEVEL_DATA[levelNum - 1];

  // Background tiling or fallback
  if (imgBG.complete && imgBG.width > 0) {
    const tileW = imgBG.width;
    const startX = -((camera.x % tileW + tileW) % tileW) - tileW;
    for (let bx = startX; bx < canvas.width; bx += tileW) ctx.drawImage(imgBG, bx, 0);
  } else {
    ctx.fillStyle = '#80c0ff'; ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  // Player movement physics
  const actualAccel = input.run ? RUN_ACCEL : WALK_ACCEL;
  if (input.left) player.vx -= actualAccel;
  if (input.right) player.vx += actualAccel;
  const maxSpd = input.run ? MAX_RUN : MAX_WALK;
  player.vx = Math.max(-maxSpd, Math.min(maxSpd, player.vx));
  if (input.jump && player.onGround) {
    player.vy = JUMP_VY;
    player.onGround = false;
    if (input.right) player.vx += JUMP_HOR_BOOST;
    else if (input.left) player.vx -= JUMP_HOR_BOOST;
  }
  player.vx *= FRICTION;
  player.vy += GRAVITY;
  if (player.vy > MAX_FALL) player.vy = MAX_FALL;
  player.x += player.vx;
  player.y += player.vy;

  // Draw + collide with platforms
  player.onGround = false;
  for (const p of L.platforms) {
    if (imgGround.complete && imgGround.width > 0) {
      for (let gx = p.x; gx < p.x + p.w; gx += imgGround.width) {
        ctx.drawImage(imgGround, worldToScreen(gx), p.y, imgGround.width, p.h);
      }
    } else {
      ctx.fillStyle = '#6b4'; ctx.fillRect(worldToScreen(p.x), p.y, p.w, p.h);
    }
    // collision AABB
    if (player.x + player.w > p.x && player.x < p.x + p.w && player.y + player.h > p.y && player.y < p.y + p.h) {
      const prevX = player.x - player.vx, prevY = player.y - player.vy;
      if (prevY + player.h <= p.y) {
        player.y = p.y - player.h; player.vy = 0; player.onGround = true;
      } else if (prevY >= p.y + p.h) {
        player.y = p.y + p.h; player.vy = 0;
      } else {
        if (prevX + player.w <= p.x) { player.x = p.x - player.w; player.vx = 0; }
        else if (prevX >= p.x + p.w) { player.x = p.x + p.w; player.vx = 0; }
      }
    }
  }

  // Camera horizontal follow
  camera.x = player.x - canvas.width / 2 + player.w / 2;
  if (camera.x < 0) camera.x = 0;

  // Draw player
  if (imgPlayer.complete) ctx.drawImage(imgPlayer, worldToScreen(player.x), player.y, player.w, player.h);
  else { ctx.fillStyle = 'cyan'; ctx.fillRect(worldToScreen(player.x), player.y, player.w, player.h); }

  // ---------- Enemies & Boss ----------
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    if (e.boss) {
      // movement uses moveMultiplier (slowed after fling)
      const moveMul = (FRAME < (e.slowMoveUntil || 0)) ? (e.moveMultiplier * 0.5) : e.moveMultiplier;
      e.x += 0.8 * e.dir * moveMul;
      const ground = L.platforms[0];
      if (e.x < ground.x + 16) { e.dir = 1; e.x = ground.x + 16; }
      if (e.x + e.w > ground.x + ground.w - 16) { e.dir = -1; e.x = ground.x + ground.w - 16 - e.w; }

      // Setup laser timer when HP drops below 20
      if (e.hp < 20 && (!e.nextLaserFrame || e.nextLaserFrame > FRAME + 200000)) {
        e.nextLaserFrame = FRAME + 20 * 60; // 20 seconds
      }

      // ORBIT spawn: every 15s uses orbitCooldown frames
      e.orbitCooldown = (e.orbitCooldown || 900) - 1;
      if (e.orbitCooldown <= 0) {
        // spawn orbit (5s = 300 frames)
        spawnOrbitAroundPlayer(e, 20, 110, 300, 0.08);
        // mark orbitActiveUntil set inside spawn
        // reset to 15s again
        e.orbitCooldown = 900;
      }

      // Direct fire: if orbit active then slow fire, else faster
      const inOrbit = FRAME < (e.slowUntilFrame || 0);
      const directBase = inOrbit ? (e.orbitSlowFireCooldown || 240) : (e.directFireCooldownBase || 8);
      if (!e.cooldown || e.cooldown <= 0) {
        const dx = (player.x + player.w / 2) - (e.x + e.w / 2);
        const dy = (player.y + player.h / 2) - (e.y + e.h / 2);
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const speed = 6.2;
        fireballs.push({ x: e.x + e.w / 2, y: e.y + e.h / 2, vx: dx / dist * speed, vy: dy / dist * speed, life: 240, owner: 'boss' });
        e.cooldown = directBase;
      }
      e.cooldown = Math.max(0, (e.cooldown || 0) - 1);

      // Laser: when hp < 20 and nextLaserFrame reached
      if (e.hp < 20 && e.nextLaserFrame && FRAME >= e.nextLaserFrame) {
        spawnLaserFromBoss(e, 90);
        e.nextLaserFrame = FRAME + 20 * 60;
      }

      // If orbit just ended this frame (do fling + slow movement)
      if (e.orbitActiveUntil && FRAME === e.orbitActiveUntil) {
        // fling: push boss away from player
        const flingVel = 10;
        if ((e.x + e.w / 2) < (player.x + player.w / 2)) e.vx = -flingVel;
        else e.vx = flingVel;
        // apply immediate position change to make fling visible
        e.x += e.vx;
        // slow movement for some seconds after fling
        e.slowMoveUntil = FRAME + 360; // ~6s
        // clear orbitActiveUntil so we don't keep re-triggering
        e.orbitActiveUntil = 0;
      }

      // simple damping for any temporary vx set by fling
      if (Math.abs(e.vx) > 0.01) {
        e.x += e.vx;
        e.vx *= 0.9;
        if (Math.abs(e.vx) < 0.3) e.vx = 0;
      }

      // Draw boss
      if (imgBoss.complete) ctx.drawImage(imgBoss, worldToScreen(e.x), e.y, e.w, e.h);
      else { ctx.fillStyle = 'purple'; ctx.fillRect(worldToScreen(e.x), e.y, e.w, e.h); }

      // Draw boss HP
      ctx.fillStyle = 'black'; ctx.font = '16px sans-serif'; ctx.fillText('Boss HP: ' + e.hp, worldToScreen(e.x), e.y - 8);
    } else {
      // normal enemy patrol
      e.x += e.speed * e.dir;
      if (e.x < e.patrolMin) { e.dir = 1; e.x = e.patrolMin; }
      if (e.x > e.patrolMax) { e.dir = -1; e.x = e.patrolMax; }
      if (imgEnemy.complete) ctx.drawImage(imgEnemy, worldToScreen(e.x), e.y, e.w, e.h);
      else { ctx.fillStyle = 'red'; ctx.fillRect(worldToScreen(e.x), e.y, e.w, e.h); }
    }
  }

  // ---------- Orbiters update & draw ----------
  for (let oi = orbiters.length - 1; oi >= 0; oi--) {
    const orb = orbiters[oi];
    orb.t += orb.speed;
    orb.life--;
    // center on player (small side wobble driven by game.time)
    const sideBias = Math.sin(game.time * 1.3) * 40;
    const cx = player.x + player.w / 2 + sideBias;
    const cy = player.y + player.h / 2;
    for (let k = 0; k < orb.count; k++) {
      const ang = orb.t + (k * (Math.PI * 2 / orb.count));
      const ox = cx + Math.cos(ang) * orb.radius;
      const oy = cy + Math.sin(ang) * orb.radius;
      if (imgBall.complete) ctx.drawImage(imgBall, worldToScreen(ox - 8), oy - 8, 16, 16);
      else { ctx.fillStyle = 'orange'; ctx.fillRect(worldToScreen(ox - 8), oy - 8, 16, 16); }
      // collision
      if (player.invulnerable <= 0 && player.x < ox + 8 && player.x + player.w > ox - 8 && player.y < oy + 8 && player.y + player.h > oy - 8) {
        player.health -= 1;
        player.invulnerable = 90;
        player.x = Math.max(10, player.x - 60);
        try { new Audio('ow.mp3').play(); } catch (e) {}
        if (player.health <= 0) {
          player.lives -= 1;
          if (player.lives <= 0) {
            try { enemy && enemy.pause && enemy.pause(); } catch (e) {}
            gameState = 'levelselect';
            player.lives = 3; player.health = 3;
            return;
          } else {
            resetLevel(levelNum);
            return;
          }
        }
      }
    }
    if (orb.life <= 0) orbiters.splice(oi, 1);
  }

  // ---------- Lasers update & draw ----------
  for (let li = lasers.length - 1; li >= 0; li--) {
    const Ls = lasers[li];
    Ls.life--;
    const boss = Ls.owner;
    const sx = boss.x + boss.w / 2;
    const sy = boss.y + boss.h / 2;
    const tx = player.x + player.w / 2;
    const ty = player.y + player.h / 2;
    const vx = tx - sx, vy = ty - sy;
    const dist = Math.sqrt(vx * vx + vy * vy) || 1;
    const ang = Math.atan2(vy, vx);
    // draw blaster sprite at boss origin (rotated sprite not necessary)
    if (imgBlaster.complete) ctx.drawImage(imgBlaster, worldToScreen(sx - 16), sy - 16, 32, 32);
    else { ctx.fillStyle = 'gray'; ctx.fillRect(worldToScreen(sx - 16), sy - 16, 32, 32); }
    // beam (image or rectangle)
    if (imgLaser.complete && imgLaser.width > 0) {
      ctx.save();
      ctx.translate(worldToScreen(sx), sy);
      ctx.rotate(ang);
      ctx.drawImage(imgLaser, 0, -12, dist, 24);
      ctx.restore();
    } else {
      ctx.save();
      ctx.translate(worldToScreen(sx), sy);
      ctx.rotate(ang);
      ctx.fillStyle = 'rgba(255,40,40,0.95)';
      ctx.fillRect(0, -8, dist, 16);
      ctx.restore();
    }
    // damage player if close to beam segment
    const d = pointToSegmentDist(player.x + player.w / 2, player.y + player.h / 2, sx, sy, tx, ty);
    if (d <= (Ls.width + Math.max(player.w, player.h) * 0.5) && player.invulnerable <= 0) {
      player.health -= 1;
      player.invulnerable = 90;
      try { new Audio('ow.mp3').play(); } catch (e) {}
      if (player.health <= 0) {
        player.lives -= 1;
        if (player.lives <= 0) { gameState = 'levelselect'; player.lives = 3; player.health = 3; return; }
        else { resetLevel(levelNum); return; }
      }
    }
    if (Ls.life <= 0) lasers.splice(li, 1);
  }

  // ---------- Direct fireballs update & draw ----------
  for (let i = fireballs.length - 1; i >= 0; i--) {
    const b = fireballs[i];
    b.x += b.vx; b.y += b.vy; b.life--;
    if (imgBall.complete) ctx.drawImage(imgBall, worldToScreen(b.x), b.y, 16, 16);
    else { ctx.fillStyle = 'orange'; ctx.fillRect(worldToScreen(b.x), b.y, 16, 16); }
    // collision
    if (player.invulnerable <= 0 && player.x < b.x + 16 && player.x + player.w > b.x && player.y < b.y + 16 && player.y + player.h > b.y) {
      player.health -= 1;
      player.invulnerable = 90;
      player.x = Math.max(10, player.x - 60);
      try { new Audio('ow.mp3').play(); } catch (e) {}
      fireballs.splice(i, 1);
      if (player.health <= 0) {
        player.lives -= 1;
        if (player.lives <= 0) { gameState = 'levelselect'; player.lives = 3; player.health = 3; }
        else { resetLevel(levelNum); }
      }
      continue;
    }
    if (b.life <= 0) fireballs.splice(i, 1);
  }

  // ---------- Player vs enemies collisions & stomps ----------
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    if (!e.boss) {
      // stomp detection
      if (player.vy > 0 && player.y + player.h <= e.y + 12 && player.x + player.w > e.x && player.x < e.x + e.w) {
        try { new Audio('owe.mp3').play(); } catch (err) {}
        enemies.splice(i, 1);
        player.vy = -8;
        continue;
      }
      // side collision
      if (player.invulnerable <= 0 && player.x < e.x + e.w && player.x + player.w > e.x && player.y < e.y + e.h && player.y + player.h > e.y) {
        player.health -= 1;
        player.invulnerable = 90;
        player.x = Math.max(10, player.x - 40);
        try { new Audio('ow.mp3').play(); } catch (err) {}
        if (player.health <= 0) {
          player.lives -= 1;
          if (player.lives <= 0) { gameState = 'levelselect'; player.lives = 3; player.health = 3; }
          else resetLevel(levelNum);
        }
      }
    } else {
      // boss stomp
      if (player.vy > 0 && player.y + player.h <= e.y + 10 && player.x + player.w > e.x && player.x < e.x + e.w && e.hitCooldown <= 0) {
        e.hp--; e.hitCooldown = 20; player.vy = -10;
        try { new Audio("owe.mp3").play(); } catch {}
        if (e.hp <= 0) {
          try { /* stop boss music if any */ } catch {}
          gameState = "win";
          player.vx = 0; player.vy = 0;
          enemies = []; fireballs = []; orbiters = []; lasers = [];
          return;
        }
      }
      // side collision
      if (player.invulnerable <= 0 && player.x < e.x + e.w && player.x + player.w > e.x && player.y < e.y + e.h && player.y + player.h > e.y) {
        player.health -= 1; player.invulnerable = 90; player.x = Math.max(10, player.x - 60);
        try { new Audio('ow.mp3').play(); } catch (err) {}
        if (player.health <= 0) {
          player.lives -= 1;
          if (player.lives <= 0) { gameState = 'levelselect'; player.lives = 3; player.health = 3; }
          else resetLevel(levelNum);
        }
      }
      if (e.hitCooldown > 0) e.hitCooldown--;
    }
  }

  // ---------- Flags: goal logic ----------
  const anyNormalsAlive = enemies.some(e => !e.boss);
  const bossAlive = enemies.some(e => e.boss && e.hp > 0);
  for (const f of flags) {
    // Level rules:
    // - Levels 1 & 2: show flag only when all normal enemies are dead
    // - Level 3 (boss): show flag only when boss is dead (and no normals)
    if (levelNum < 3) f.visible = !anyNormalsAlive;
    else f.visible = !bossAlive && !anyNormalsAlive;

    if (!f.visible) continue;
    // draw flag
    if (imgFlag.complete) ctx.drawImage(imgFlag, worldToScreen(f.x), f.y, f.w, f.h);
    else { ctx.fillStyle = 'yellow'; ctx.fillRect(worldToScreen(f.x), f.y, f.w, f.h); }

    // touch flag -> unlock next level / levelselect
    if (player.x + player.w > f.x && player.x < f.x + f.w && player.y + player.h > f.y) {
      if (levelNum + 1 <= LEVEL_DATA.length) unlockLevel(levelNum + 1);
      if (levelNum + 1 <= LEVEL_DATA.length) resetLevel(levelNum + 1);
      gameState = 'levelselect';
    }
  }

  // invulnerability timer
  if (player.invulnerable > 0) player.invulnerable--;

  // HUD
  ctx.fillStyle = 'black';
  ctx.font = '16px sans-serif';
  ctx.fillText('Level ' + levelNum, 10, 20);
  ctx.fillText('Health: ' + player.health + '  Lives: ' + player.lives, 10, 40);
}

// ---------- Global key handling ----------
function onGlobalKey(e) {
  // Pause toggle (P)
  if (e.key.toLowerCase() === 'p' && gameState === 'playing') {
    paused = !paused;
  }

  // Menu -> levelselect (Z)
  if (gameState === 'menu' && e.key.toLowerCase() === 'z') {
    gameState = 'levelselect';
    return;
  }

  // Level select keys (1,2,3)
  if (gameState === 'levelselect') {
    if (e.key === '1' && unlockedLevels.includes(1)) { currentLevel = 1; resetLevel(1); gameState = 'playing'; return; }
    if (e.key === '2' && unlockedLevels.includes(2)) { currentLevel = 2; resetLevel(2); gameState = 'playing'; return; }
    if (e.key === '3' && unlockedLevels.includes(3)) { currentLevel = 3; resetLevel(3); gameState = 'playing'; return; }
    if (e.key.toLowerCase() === 'z') { gameState = 'menu'; return; }
  }

  // Pause -> menu (M)
  if (paused && e.key.toLowerCase() === 'm') {
    paused = false; gameState = 'menu';
    return;
  }
}
window.addEventListener('keydown', onGlobalKey);

// ---------- Main game loop ----------
let lastTime = performance.now();
function gameLoop(now) {
  const dt = Math.min(0.05, (now - lastTime) / 1000);
  lastTime = now;
  game.time += dt;
  FRAME++;

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (gameState === 'menu') {
    ctx.fillStyle = 'black'; ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'white'; ctx.font = '28px sans-serif'; ctx.fillText('SUPER CHIRK', 50, 50);
    ctx.font = '16px sans-serif'; ctx.fillText('Press Z to Start (level select)', 50, 100);
  } else if (gameState === 'levelselect') {
    // draw level select
    ctx.fillStyle = 'black'; ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'white'; ctx.font = '24px sans-serif'; ctx.fillText('LEVEL SELECT', 50, 50);
    unlockedLevels.forEach((lv, i) => ctx.fillText('Level ' + lv, 60, 120 + i * 40));
    ctx.font = '14px sans-serif';
    ctx.fillText('Press 1/2/3 to start unlocked level. Press Z to return to menu.', 50, canvas.height - 40);
  } else if (gameState === 'playing') {
    if (!paused) runLevel(currentLevel);
    else {
      ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = 'white'; ctx.font = '32px sans-serif'; ctx.fillText('PAUSED', 120, 120);
      ctx.font = '18px sans-serif'; ctx.fillText('Press P to Resume', 110, 170); ctx.fillText('Press M for Menu', 110, 200);
    }
  } else if (gameState === 'win') {
    ctx.fillStyle = 'black'; ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'white'; ctx.font = '28px sans-serif'; ctx.fillText('YOU WIN!', 50, 50);
    ctx.font = '16px sans-serif'; ctx.fillText('Game permanently locked.', 50, 100);
  }

  requestAnimationFrame(gameLoop);
}

// ---------- Start / Init ----------
function startGame() {
  canvas = document.getElementById('game');
  ctx = canvas.getContext('2d');
  ctx.imageSmoothingEnabled = false;
  resetLevel(currentLevel);
  requestAnimationFrame(gameLoop);
}

// fallback: if images never fire onload quickly, ensure startGame still runs
setTimeout(() => { if (!canvas) startGame(); }, 1200);

</script>
</body>
</html>


