<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Super Chirk — Mini Platformer (Fixed + Boss Orbit + Laser)</title>
<style>
  html,body{height:100%;margin:0;background:#000;display:flex;align-items:center;justify-content:center;font-family:system-ui,Segoe UI,Roboto}
  canvas{background:#000;image-rendering:pixelated}
  #ui{position:fixed;left:12px;top:12px;color:#fff}
  button{padding:8px 12px;margin:6px}
</style>
</head>
<body>
<canvas id="game" width="960" height="540"></canvas>
<div id="ui"></div>

<script>
// === Super Chirk — Complete single-file version (Fixed + Orbit + Laser) ===

// ---------- Globals ----------
let canvas = null, ctx = null;
let gameState = "menu"; // menu, levelselect, cutscene, playing, win
let currentLevel = 1;
let unlockedLevels = JSON.parse(localStorage.getItem("unlockedLevels") || "[1]");
let game = { time: 0 };
let paused = false;
let FRAME = 0; // global frame counter

// Music & cutscene
let bgm = null, bossMusic = null, cutsceneMusic = null;
let inCutscene = false, cutsceneTimer = 0;
const cutsceneDialogue = [
  "wow",
  "you really made it this far",
  "It seems that your DEKIRKINATION took you pretty far.",
  "but no matter.",
  "your journey ends NOW"
];

// ---------- Player / World ----------
let player = { x: 50, y: 240, w: 32, h: 48, vx: 0, vy: 0, onGround: false, facing: 1, health: 3, lives: 3, invulnerable: 0 };
let enemies = [];
let fireballs = []; // direct boss projectiles and generic bullets
let orbiters = [];  // orbiting rings (visual + collision)
let lasers = [];    // active giant laser beams
let flags = [];
let camera = { x: 0, y: 0 };

// Gameplay constants
const GRAVITY = 0.8, MAX_FALL = 18;
const FRICTION = 0.88;
const WALK_ACCEL = 0.35, RUN_ACCEL = 0.6, MAX_WALK = 3.5, MAX_RUN = 6;
const JUMP_VY = -16; // MEDIUM-HIGH JUMP
const JUMP_HOR_BOOST = 2.5;

// Input
const input = { left: false, right: false, jump: false, run: false };
window.addEventListener('keydown', e => {
  if (e.key === 'ArrowLeft') input.left = true;
  if (e.key === 'ArrowRight') input.right = true;
  if (e.key.toLowerCase() === 'z') input.jump = true;
  if (e.key.toLowerCase() === 'x') input.run = true;
});
window.addEventListener('keyup', e => {
  if (e.key === 'ArrowLeft') input.left = false;
  if (e.key === 'ArrowRight') input.right = false;
  if (e.key.toLowerCase() === 'z') input.jump = false;
  if (e.key.toLowerCase() === 'x') input.run = false;
});

// ---------- Level data (platforms, enemies, flags) ----------
// Plane widths made WAY bigger as requested
const LEVEL_DATA = [
  {
    platforms: [{ x: 0, y: 360, w: 8000, h: 40 }, { x: 800, y: 300, w: 400, h: 16 }, { x: 1600, y: 250, w: 400, h: 16 }],
    enemies: [{ x: 420, patrol: [380, 520] }],
    flags: [{ x: 4000, w: 32, h: 80 }]
  },
  {
    platforms: [{ x: 0, y: 360, w: 8000, h: 40 }, { x: 600, y: 300, w: 400, h: 16 }, { x: 1400, y: 260, w: 400, h: 16 }, { x: 2200, y: 220, w: 400, h: 16 }],
    enemies: [{ x: 800, patrol: [760, 940] }, { x: 1800, patrol: [1720, 1840] }],
    flags: [{ x: 4200, w: 32, h: 80 }]
  },
  {
    platforms: [{ x: 0, y: 360, w: 8000, h: 40 }, { x: 900, y: 300, w: 400, h: 16 }, { x: 1900, y: 260, w: 400, h: 16 }, { x: 2800, y: 220, w: 400, h: 16 }],
    enemies: [{ boss: true, x: 1200, hp: 30, dir: 1 }], // boss HP = 30
    flags: [{ x: 4600, w: 32, h: 128 }]
  }
];

// ---------- Images ----------
let imgPlayer = new Image(); imgPlayer.src = "chirk.png";
let imgEnemy = new Image(); imgEnemy.src = "cheese.png";
let imgBoss = new Image(); imgBoss.src = "supercheese.png";
let imgBall = new Image(); imgBall.src = "BALL.png";
let imgFlag = new Image(); imgFlag.src = "flag.png";
let imgBG = new Image(); imgBG.src = "bg.png";
let imgGround = new Image(); imgGround.src = "g.png";
let imgBlaster = new Image(); imgBlaster.src = "blaster.png"; // for laser origin sprite
let imgLaser = new Image(); imgLaser.src = "laser.png";       // beam graphic

function worldToScreen(x) { return Math.round(x - camera.x); }

// ---------- Utilities ----------
function unlockLevel(lv) {
  if (lv <= LEVEL_DATA.length && !unlockedLevels.includes(lv)) {
    unlockedLevels.push(lv);
    localStorage.setItem("unlockedLevels", JSON.stringify(unlockedLevels));
  }
}

// Reset a level: spawn enemies and flags and place them properly on platforms
function resetLevel(levelNum) {
  const L = LEVEL_DATA[levelNum - 1];
  enemies = []; fireballs = []; flags = []; orbiters = []; lasers = [];
  player.x = 60; player.y = 200; player.vx = 0; player.vy = 0; player.onGround = false; player.invulnerable = 0;

  // Spawn enemies — ensure correct y (on top of the platform) and clamp patrol ranges to platform
  if (L.enemies) for (const e of L.enemies) {
    if (e.boss) {
      // Boss: place on ground platform (first platform assumed ground)
      const ground = L.platforms[0];
      const bx = Math.max(ground.x + 16, Math.min(e.x, ground.x + ground.w - 80));
      enemies.push({
        boss: true,
        x: bx,
        y: ground.y - 64,
        w: 64,
        h: 64,
        hp: (e.hp || 30),
        cooldown: 0,
        dir: e.dir || 1,
        hitCooldown: 0,
        // frame-based cooldowns:
        directFireCooldownBase: 12, // default direct-fire base (frames) -> very fast
        slowUntilFrame: 0,          // when spiral slows direct fire, set to FRAME + duration
        orbitCooldown: 240,         // frames until next orbit (~4s)
        nextLaserFrame: FRAME + 999999 // placeholder; set once hp<20
      });
    } else {
      // Normal enemy: find platform underneath or default to ground
      const plat = L.platforms.find(p => e.x >= p.x && e.x <= p.x + p.w) || L.platforms[0];
      const ex = Math.max(plat.x + 4, Math.min(e.x, plat.x + plat.w - 32));
      const patrolMin = Math.max(e.patrol[0], plat.x);
      const patrolMax = Math.min(e.patrol[1], plat.x + plat.w - 32);
      enemies.push({ boss: false, x: ex, y: plat.y - 32, w: 32, h: 32, patrolMin: patrolMin, patrolMax: patrolMax, dir: 1, speed: 1.2 });
    }
  }

  // Spawn flags and place them on top of the platform that covers the flag.x
  if (L.flags) for (const f of L.flags) {
    const plat = L.platforms.find(p => f.x >= p.x && f.x <= p.x + p.w) || L.platforms[0];
    // hide boss flag until boss dead (visible true for non-boss levels)
    flags.push({ x: f.x, y: plat.y - f.h, w: f.w, h: f.h, visible: (levelNum !== 3) });
  }
}

// ---------- Orbit helpers ----------
function spawnOrbitAroundPlayer(bossRef, count = 16, radius = 80, lifetimeFrames = 420, speed = 0.08) {
  // bossRef slowdown: reduce direct fire to once every 4 seconds (240 frames)
  bossRef.slowUntilFrame = Math.max(bossRef.slowUntilFrame || 0, FRAME + lifetimeFrames);
  // push orbit entry
  orbiters.push({ boss: bossRef, t: 0, count, radius, life: lifetimeFrames, speed, createdAtFrame: FRAME });
}

// ---------- Laser helpers ----------
function spawnLaserFromBoss(bossRef, lifeFrames = 90) {
  // spawn a laser object which stores source (blaster) and target (player)
  const blasterX = bossRef.x + bossRef.w / 2;
  const blasterY = bossRef.y + bossRef.h / 2;
  lasers.push({
    owner: bossRef,
    sx: blasterX, sy: blasterY,
    life: lifeFrames,
    maxLife: lifeFrames,
    createdAt: FRAME,
    width: 16 // beam half-width (used for collision)
  });
}

// point-to-segment distance (used for laser collision)
function pointToSegmentDist(px, py, x1, y1, x2, y2) {
  const vx = x2 - x1, vy = y2 - y1;
  const wx = px - x1, wy = py - y1;
  const c = (wx * vx + wy * vy) / (vx * vx + vy * vy || 1);
  const t = Math.max(0, Math.min(1, c));
  const rx = x1 + vx * t, ry = y1 + vy * t;
  const dx = px - rx, dy = py - ry;
  return Math.sqrt(dx * dx + dy * dy);
}

// ---------- Main runLevel (complete) ----------
function runLevel(levelNum) {
  const L = LEVEL_DATA[levelNum - 1];

  // Background
  if (imgBG.complete && imgBG.width > 0) {
    const tileW = imgBG.width;
    const startX = -((camera.x % tileW + tileW) % tileW) - tileW;
    for (let bx = startX; bx < canvas.width; bx += tileW) ctx.drawImage(imgBG, bx, 0);
  } else {
    ctx.fillStyle = '#80c0ff'; ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  // Player movement physics
  const actualAccel = input.run ? RUN_ACCEL : WALK_ACCEL;
  if (input.left) player.vx -= actualAccel;
  if (input.right) player.vx += actualAccel;
  const maxSpd = input.run ? MAX_RUN : MAX_WALK;
  player.vx = Math.max(-maxSpd, Math.min(maxSpd, player.vx));

  // Jump (higher jump requested)
  if (input.jump && player.onGround) {
    player.vy = JUMP_VY; // -16
    player.onGround = false;
    if (input.right) player.vx += JUMP_HOR_BOOST;
    else if (input.left) player.vx -= JUMP_HOR_BOOST;
  }
  // friction and gravity
  player.vx *= FRICTION;
  player.vy += GRAVITY;
  if (player.vy > MAX_FALL) player.vy = MAX_FALL;
  player.x += player.vx;
  player.y += player.vy;

  // Draw and collide with platforms (AABB with previous-position checks)
  player.onGround = false;
  for (const p of L.platforms) {
    // Draw ground tile (repeat)
    if (imgGround.complete && imgGround.width > 0) {
      for (let gx = p.x; gx < p.x + p.w; gx += imgGround.width) {
        ctx.drawImage(imgGround, worldToScreen(gx), p.y, imgGround.width, p.h);
      }
      const remainder = p.w % imgGround.width;
      if (remainder > 0) {
        ctx.drawImage(imgGround, 0, 0, remainder, imgGround.height, worldToScreen(p.x + Math.floor(p.w / imgGround.width) * imgGround.width), p.y, remainder, p.h);
      }
    } else {
      ctx.fillStyle = '#6b4'; ctx.fillRect(worldToScreen(p.x), p.y, p.w, p.h);
    }

    // Collision
    if (player.x + player.w > p.x && player.x < p.x + p.w && player.y + player.h > p.y && player.y < p.y + p.h) {
      const prevX = player.x - player.vx, prevY = player.y - player.vy;
      if (prevY + player.h <= p.y) {
        // landed on top
        player.y = p.y - player.h;
        player.vy = 0;
        player.onGround = true;
      } else if (prevY >= p.y + p.h) {
        // hit bottom
        player.y = p.y + p.h;
        player.vy = 0;
      } else {
        // side collision
        if (prevX + player.w <= p.x) { player.x = p.x - player.w; player.vx = 0; }
        else if (prevX >= p.x + p.w) { player.x = p.x + p.w; player.vx = 0; }
      }
    }
  }

  // Camera (horizontal only)
  camera.x = player.x - canvas.width / 2 + player.w / 2;
  if (camera.x < 0) camera.x = 0;

  // Draw player
  if (imgPlayer.complete) ctx.drawImage(imgPlayer, worldToScreen(player.x), player.y, player.w, player.h);
  else { ctx.fillStyle = 'cyan'; ctx.fillRect(worldToScreen(player.x), player.y, player.w, player.h); }

  // ---------- Enemies & Boss ----------
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    if (e.boss) {
      const ground = L.platforms[0];
      e.x += 1.6 * e.dir;
      if (e.x < ground.x + 16) { e.dir = 1; e.x = ground.x + 16; }
      if (e.x + e.w > ground.x + ground.w - 16) { e.dir = -1; e.x = ground.x + ground.w - 16 - e.w; }

      // Setup laser timer when HP drops below 20 (frame-based)
      if (e.hp < 20 && (!e.nextLaserFrame || e.nextLaserFrame > FRAME + 200000)) {
        e.nextLaserFrame = FRAME + 20 * 60; // 20 seconds in frames (assuming ~60 FPS)
      }

      // DIRECT Shoot toward player at cooldown. Respect slowUntilFrame (slows to 240 frames = 4s).
      const directBase = (FRAME < (e.slowUntilFrame || 0)) ? 240 : (e.directFireCooldownBase || 12);
      if (!e.cooldown || e.cooldown <= 0) {
        const dx = (player.x + player.w / 2) - (e.x + e.w / 2);
        const dy = (player.y + player.h / 2) - (e.y + e.h / 2);
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const speed = 6.2;
        fireballs.push({ x: e.x + e.w / 2, y: e.y + e.h / 2, vx: dx / dist * speed, vy: dy / dist * speed, life: 240, owner: 'boss' });
        e.cooldown = directBase;
      }
      e.cooldown = Math.max(0, (e.cooldown || 0) - 1);

      // ORBIT attack: spawn an orbit every time orbitCooldown reaches 0
      e.orbitCooldown = (e.orbitCooldown || 240) - 1;
      if (e.orbitCooldown <= 0) {
        // spawn orbit: sets boss slowUntilFrame for orbit duration
        spawnOrbitAroundPlayer(e, 20, 110, 420, 0.08); // 20 orbiters for fuller circle
        // reset cooldown to 4-6 seconds
        e.orbitCooldown = 240 + Math.floor(Math.random() * 120);
      }

      // LASER attack: spawn when hp<20 and timer reached
      if (e.hp < 20 && e.nextLaserFrame && FRAME >= e.nextLaserFrame) {
        // spawn laser lasting ~1.5s (90 frames)
        spawnLaserFromBoss(e, 90);
        e.nextLaserFrame = FRAME + 20 * 60; // schedule next in 20 seconds
      }

      // Draw boss
      if (imgBoss.complete) ctx.drawImage(imgBoss, worldToScreen(e.x), e.y, e.w, e.h);
      else { ctx.fillStyle = 'purple'; ctx.fillRect(worldToScreen(e.x), e.y, e.w, e.h); }

      // Draw boss HP above boss
      ctx.fillStyle = 'black'; ctx.font = '16px sans-serif';
      ctx.fillText('Boss HP: ' + e.hp, worldToScreen(e.x), e.y - 8);
    } else {
      // Normal enemy AI — patrol and clamp to platform patrol range
      e.x += e.speed * e.dir;
      if (e.x < e.patrolMin) { e.dir = 1; e.x = e.patrolMin; }
      if (e.x > e.patrolMax) { e.dir = -1; e.x = e.patrolMax; }

      // Draw enemy
      if (imgEnemy.complete) ctx.drawImage(imgEnemy, worldToScreen(e.x), e.y, e.w, e.h);
      else { ctx.fillStyle = 'red'; ctx.fillRect(worldToScreen(e.x), e.y, e.w, e.h); }
    }
  }

  // ---------- Orbiters update & draw ----------
  for (let oi = orbiters.length - 1; oi >= 0; oi--) {
    const orb = orbiters[oi];
    orb.t += orb.speed;
    orb.life--;
    // bias oscillation based on boss.dir and game time
    let bossSide = 0;
    if (orb.boss && typeof orb.boss.x === 'number') {
      bossSide = Math.sin(game.time * 1.5) * 60 * (orb.boss.dir || 1);
    }
    // center around player
    const cx = player.x + player.w / 2 + bossSide;
    const cy = player.y + player.h / 2;
    // draw orbit points and check collision
    for (let k = 0; k < orb.count; k++) {
      const ang = orb.t + (k * (Math.PI * 2 / orb.count));
      const ox = cx + Math.cos(ang) * orb.radius;
      const oy = cy + Math.sin(ang) * orb.radius;
      if (imgBall.complete) ctx.drawImage(imgBall, worldToScreen(ox - 8), oy - 8, 16, 16);
      else { ctx.fillStyle = 'orange'; ctx.fillRect(worldToScreen(ox - 8), oy - 8, 16, 16); }

      // collision with player
      if (player.invulnerable <= 0 && player.x < ox + 8 && player.x + player.w > ox - 8 && player.y < oy + 8 && player.y + player.h > oy - 8) {
        player.health -= 1;
        player.invulnerable = 90;
        player.x = Math.max(10, player.x - 60);
        try { new Audio('ow.mp3').play(); } catch (e) {}
        if (player.health <= 0) {
          player.lives -= 1;
          if (player.lives <= 0) {
            try { bossMusic && bossMusic.pause(); } catch (e) {}
            gameState = 'levelselect';
            player.lives = 3; player.health = 3;
            return;
          } else {
            resetLevel(levelNum);
            return;
          }
        }
      }
    }
    if (orb.life <= 0) orbiters.splice(oi, 1);
  }

  // ---------- Lasers update & draw ----------
  for (let li = lasers.length - 1; li >= 0; li--) {
    const Ls = lasers[li];
    Ls.life--;
    // compute blaster source (follow boss)
    const boss = Ls.owner;
    const sx = boss.x + boss.w / 2;
    const sy = boss.y + boss.h / 2;
    // target player center
    const tx = player.x + player.w / 2;
    const ty = player.y + player.h / 2;
    const vx = tx - sx, vy = ty - sy;
    const dist = Math.sqrt(vx * vx + vy * vy) || 1;
    const ang = Math.atan2(vy, vx);

    // draw blaster sprite at boss
    if (imgBlaster.complete) ctx.drawImage(imgBlaster, worldToScreen(sx - 16), sy - 16, 32, 32);
    else { ctx.fillStyle = 'gray'; ctx.fillRect(worldToScreen(sx - 16), sy - 16, 32, 32); }

    // draw beam as stretched image (if available) or rectangle
    if (imgLaser.complete && imgLaser.width > 0) {
      // drawImage with rotation: translate to source, rotate, draw with length = dist
      ctx.save();
      ctx.translate(worldToScreen(sx), sy);
      ctx.rotate(ang);
      ctx.drawImage(imgLaser, 0, -12, dist, 24); // beam height ~24
      ctx.restore();
    } else {
      // fallback thick rectangle beam
      ctx.save();
      ctx.translate(worldToScreen(sx), sy);
      ctx.rotate(ang);
      ctx.fillStyle = 'rgba(255,40,40,0.9)';
      ctx.fillRect(0, -8, dist, 16);
      ctx.restore();
    }

    // damage check: approximate by distance from player center to beam segment
    const d = pointToSegmentDist(player.x + player.w / 2, player.y + player.h / 2, sx, sy, tx, ty);
    if (d <= (Ls.width + Math.max(player.w, player.h) * 0.5) && player.invulnerable <= 0) {
      // player hit by laser
      player.health -= 1;
      player.invulnerable = 90;
      try { new Audio('ow.mp3').play(); } catch (e) {}
      if (player.health <= 0) {
        player.lives -= 1;
        if (player.lives <= 0) {
          try { bossMusic && bossMusic.pause(); } catch (e) {}
          gameState = 'levelselect';
          player.lives = 3; player.health = 3;
          return;
        } else {
          resetLevel(levelNum);
          return;
        }
      }
    }

    if (Ls.life <= 0) lasers.splice(li, 1);
  }

  // ---------- Fireballs (direct projectiles) ----------
  for (let i = fireballs.length - 1; i >= 0; i--) {
    const b = fireballs[i];
    b.x += b.vx; b.y += b.vy; b.life--;
    if (imgBall.complete) ctx.drawImage(imgBall, worldToScreen(b.x), b.y, 16, 16);
    else { ctx.fillStyle = 'orange'; ctx.fillRect(worldToScreen(b.x), b.y, 16, 16); }

    // Collision with player
    if (player.invulnerable <= 0 && player.x < b.x + 16 && player.x + player.w > b.x && player.y < b.y + 16 && player.y + player.h > b.y) {
      player.health -= 1;
      player.invulnerable = 90;
      player.x = Math.max(10, player.x - 60);
      try { new Audio('ow.mp3').play(); } catch (e) { }
      fireballs.splice(i, 1);
      if (player.health <= 0) {
        player.lives -= 1;
        if (player.lives <= 0) {
          try { bossMusic && bossMusic.pause(); } catch (e) { }
          gameState = 'levelselect';
          player.lives = 3; player.health = 3;
        } else {
          resetLevel(levelNum);
        }
      }
      continue;
    }

    if (b.life <= 0) fireballs.splice(i, 1);
  }

  // ---------- Player vs Enemies collisions & stomps ----------
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    if (!e.boss) {
      // stomp detection
      if (player.vy > 0 && player.y + player.h <= e.y + 12 && player.x + player.w > e.x && player.x < e.x + e.w) {
        try { new Audio('owe.mp3').play(); } catch (err) { }
        enemies.splice(i, 1);
        player.vy = -8;
        continue;
      }
      // side collision damage
      if (player.invulnerable <= 0 && player.x < e.x + e.w && player.x + player.w > e.x && player.y < e.y + e.h && player.y + player.h > e.y) {
        player.health -= 1;
        player.invulnerable = 90;
        player.x = Math.max(10, player.x - 40);
        try { new Audio('ow.mp3').play(); } catch (err) { }
        if (player.health <= 0) {
          player.lives -= 1;
          if (player.lives <= 0) {
            try { bossMusic && bossMusic.pause(); } catch (err) { }
            gameState = 'levelselect';
            player.lives = 3; player.health = 3;
          } else resetLevel(levelNum);
        }
      }
    } else {
      // ---------- BOSS INTERACTIONS ----------
      if (player.vy > 0 && player.y + player.h <= e.y + 10 && player.x + player.w > e.x && player.x < e.x + e.w && e.hitCooldown <= 0) {
        e.hp--;
        e.hitCooldown = 20;
        player.vy = -10;
        try { new Audio("owe.mp3").play(); } catch {}
        if (e.hp <= 0) {
          try { bossMusic.pause(); bossMusic.currentTime = 0; } catch {}
          gameState = "win";
          player.vx = 0; player.vy = 0;
          enemies = []; fireballs = []; orbiters = []; lasers = [];
          return;
        }
      }

      // Side collision with boss damages the player
      if (player.invulnerable <= 0 && player.x < e.x + e.w && player.x + player.w > e.x && player.y < e.y + e.h && player.y + player.h > e.y) {
        player.health -= 1;
        player.invulnerable = 90;
        player.x = Math.max(10, player.x - 60);
        try { new Audio('ow.mp3').play(); } catch (err) { }
        if (player.health <= 0) {
          player.lives -= 1;
          if (player.lives <= 0) {
            try { bossMusic && bossMusic.pause(); } catch (err) { }
            gameState = 'levelselect';
            player.lives = 3; player.health = 3;
          } else resetLevel(levelNum);
        }
      }

      if (e.hitCooldown > 0) e.hitCooldown--;
    }
  }

  // ---------- Flags: show only after enemies dead (in boss level) ----------
  const bossAlive = enemies.some(e => e.boss && e.hp > 0);
  const normalEnemiesAlive = enemies.some(e => !e.boss);

  for (const f of flags) {
    if (bossAlive || normalEnemiesAlive) f.visible = false;
    else f.visible = true;

    if (!f.visible) continue;

    if (imgFlag.complete) ctx.drawImage(imgFlag, worldToScreen(f.x), f.y, f.w, f.h);
    else { ctx.fillStyle = 'yellow'; ctx.fillRect(worldToScreen(f.x), f.y, f.w, f.h); }

    // Player touches flag
    if (player.x + player.w > f.x && player.x < f.x + f.w && player.y + player.h > f.y) {
      if (levelNum + 1 <= LEVEL_DATA.length) unlockLevel(levelNum + 1);
      if (levelNum + 1 <= LEVEL_DATA.length) resetLevel(levelNum + 1);
      gameState = 'levelselect';
    }
  }

  // invulnerability timer
  if (player.invulnerable > 0) player.invulnerable--;

  // HUD (black text)
  ctx.fillStyle = 'black';
  ctx.font = '16px sans-serif';
  ctx.fillText('Level ' + levelNum, 10, 20);
  ctx.fillText('Health: ' + player.health + '  Lives: ' + player.lives, 10, 40);
}

// ---------- Global key handling (menu/pause/level select) ----------
function onGlobalKey(e) {
  if (e.key.toLowerCase() === 'p' && gameState === 'playing') {
    paused = !paused;
    if (paused) { try { bgm && bgm.pause(); bossMusic && bossMusic.pause(); } catch (err) { } }
    else { try { if (currentLevel === 3) bossMusic && bossMusic.play(); else bgm && bgm.play(); } catch (err) { } }
  }

  if (paused && e.key.toLowerCase() === 'm') {
    paused = false;
    try { bgm && bgm.play(); } catch (err) { }
    gameState = 'menu';
  }

  if (gameState === 'menu' && e.key.toLowerCase() === 'z') {
    gameState = 'levelselect';
    return;
  }

  if (gameState === 'levelselect') {
    if (e.key === '1' && unlockedLevels.includes(1)) {
      currentLevel = 1; resetLevel(1); try { bgm.currentTime = 0; bgm && bgm.play(); } catch (err) { } gameState = 'playing'; return;
    }
    if (e.key === '2' && unlockedLevels.includes(2)) {
      currentLevel = 2; resetLevel(2); try { bgm.currentTime = 0; bgm && bgm.play(); } catch (err) { } gameState = 'playing'; return;
    }
    if (e.key === '3' && unlockedLevels.includes(3)) {
      inCutscene = true;
      cutsceneTimer = 0;
      try { bgm && bgm.pause(); bossMusic && bossMusic.pause(); } catch (err) { }
      gameState = 'cutscene';
      return;
    }
    if (e.key.toLowerCase() === 'z') {
      gameState = 'menu';
      return;
    }
  }
}
window.addEventListener('keydown', onGlobalKey);

// ---------- Main game loop ----------
let lastTime = performance.now();
function gameLoop(now) {
  const dt = Math.min(0.05, (now - lastTime) / 1000);
  lastTime = now;
  game.time += dt;
  FRAME++;

  // clear
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (gameState === 'menu') {
    ctx.fillStyle = 'black'; ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'white';
    ctx.font = '28px sans-serif';
    ctx.fillText('SUPER CHIRK', 50, 50);
    ctx.font = '16px sans-serif';
    ctx.fillText('Press Z to Start (level select)', 50, 100);
  } else if (gameState === 'levelselect') {
    // draw level select
    ctx.fillStyle = "black"; ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "white"; ctx.font = "24px sans-serif"; ctx.fillText("LEVEL SELECT", 50, 50);
    unlockedLevels.forEach((lv, i) => ctx.fillText("Level " + lv, 60, 120 + i * 40));
    ctx.font = "14px sans-serif";
    ctx.fillText("Press 1/2/3 to start unlocked level. Press Z to return to menu.", 50, canvas.height - 40);
  } else if (gameState === 'cutscene') {
    ctx.fillStyle = 'black'; ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'white'; ctx.font = '24px sans-serif';
    if (cutsceneTimer === 0) { try { cutsceneMusic.currentTime = 0; cutsceneMusic.play().catch(() => { }); } catch (err) { } }
    let lineIndex = Math.floor((cutsceneTimer / 22) * cutsceneDialogue.length);
    if (lineIndex >= cutsceneDialogue.length) lineIndex = cutsceneDialogue.length - 1;
    ctx.fillText(cutsceneDialogue[lineIndex], 120, 150);
    cutsceneTimer += dt;
    if (cutsceneTimer >= 22) {
      try { cutsceneMusic.pause(); } catch (err) { }
      inCutscene = false;
      currentLevel = 3;
      try { bossMusic.currentTime = 0; bossMusic.play().catch(() => { }); } catch (err) { }
      resetLevel(3);
      gameState = 'playing';
    }
  } else if (gameState === 'playing') {
    if (!paused) runLevel(currentLevel);
    else {
      ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = 'white'; ctx.font = '32px sans-serif'; ctx.fillText('PAUSED', 120, 120);
      ctx.font = '18px sans-serif'; ctx.fillText('Press P to Resume', 110, 170); ctx.fillText('Press M for Menu', 110, 200);
    }
  } else if (gameState === 'win') {
    ctx.fillStyle = 'black'; ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'white'; ctx.font = '28px sans-serif'; ctx.fillText('YOU WIN!', 50, 50);
    ctx.font = '16px sans-serif'; ctx.fillText('Game permanently locked.', 50, 100);
  }

  requestAnimationFrame(gameLoop);
}

// ---------- Init ----------
window.onload = () => {
  canvas = document.getElementById('game');
  ctx = canvas.getContext('2d');
  ctx.imageSmoothingEnabled = false;
  initMusic();
  resetLevel(1);
  requestAnimationFrame(gameLoop);
};

// Music init (kept at bottom so images exist earlier)
function initMusic() {
  bgm = new Audio("bgm.mp3"); bgm.loop = true; bgm.volume = 0.5;
  bossMusic = new Audio("boss.mp3"); bossMusic.loop = true; bossMusic.volume = 0.7;
  cutsceneMusic = new Audio("cut.mp3"); cutsceneMusic.loop = false; cutsceneMusic.volume = 0.8;
  try { bgm.play().catch(() => {}); } catch (e) {}
}
</script>
</body>
</html>


